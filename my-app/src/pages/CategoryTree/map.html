<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

</body>
<script>
    const rawData = [
            {
                "id": "basic",
                "name": "通用基础分析",
                "description": "通用基础分析主要关注地理空间对象的特征量算、时空检索、相互关系等基础分析功能，为深层次分析算法、模型及解决实际问题提供支撑。",
                "allModelsRecursive": [],
                "models": [
                    {
                        "id": "9b9cc2f6-d5fe-38d6-87ec-902cfe27f59d",
                        "name": "地图代数运算",
                        "description": "以代数运算的方式对地理空间对象的特征和属性执行各种地理分析。"
                    }
                ],
                "categories": [
                    {
                        "id": "feature_quantification",
                        "name": "特征量算",
                        "description": "特征量算是计算地理空间对象几何特征和属性特征的算法。",
                        "allModelsRecursive": [],
                        "models": [
                            {
                                "id": "67631d1d-5e33-33de-ba31-e52026481dc8",
                                "name": "几何中心量算",
                                "description": "计算地理空间对象在某个空间参考下的几何中心。"
                            },
                            {
                                "id": "6cd573d0-eac8-3263-89cc-aae184812b55",
                                "name": "表面积量算",
                                "description": "计算地理空间对象在某个空间参考下的曲面体表面积的特征量算。"
                            }
                        ],
                        "categories": []
                    },
                    {
                        "id": "neighbor_analysis",
                        "name": "邻域分析",
                        "description": "邻域分析是以某一个地理空间对象为中心，根据规则向周围空间扩展一定的范围，以利用扩展范围内的对象进行复合运算的分析算法。",
                        "allModelsRecursive": [],
                        "models": [
                            {
                                "id": "89d5a3e1-35a1-3015-8b13-8a4c0b26a4cf",
                                "name": "缓冲区分析（basic）",
                                "description": "该算法使用固定或动态距离为输入要素中的所有要素计算缓冲区。"
                            },
                            {
                                "id": "2eac0350-d521-30f1-b08f-ca0495f5e877",
                                "name": "缓冲区分析（buffer ring）",
                                "description": "基于向量的缓冲区构造部分基于Dong等人（2003）提出的方法。"
                            },
                            {
                                "id": "4be2ea4e-7053-34a9-8d5c-366fd788dd68",
                                "name": "缓冲区分析（栅格-GeoTIFF）",
                                "description": "该工具可用于识别光栅数据集中所需特征指定距离内的邻域区域。"
                            }
                        ],
                        "categories": []
                    },
                    {
                        "id": "overlay",
                        "name": "叠置分析",
                        "description": "叠置分析将多个（层）对象进行交、并、补等叠置分析产生一个新的对象。",
                        "allModelsRecursive": [],
                        "models": [
                            {
                                "id": "b95b3c48-1ea4-3d4b-9ab8-94642c2dabb6",
                                "name": "叠置分析（补）",
                                "description": "将多个（层）对象进行叠置分析（补）产生一个新的对象。"
                            },
                            {
                                "id": "b7cd78ed-736b-3d7a-86b9-74df249e7a22",
                                "name": "叠置分析（交）",
                                "description": "将多个（层）对象进行叠置分析（交）产生一个新的对象。"
                            },
                            {
                                "id": "a1d0db36-0433-3c10-a12b-b10add5c25e6",
                                "name": "叠置分析（并）",
                                "description": "将多个（层）对象进行叠置分析（并）产生一个新的对象。"
                            }
                        ],
                        "categories": []
                    },
                    {
                        "id": "st_relation_calculation",
                        "name": "时空关系计算",
                        "description": "时空关系计算是确定地理空间对象间在时空等维度上相互关系的算法。",
                        "allModelsRecursive": [],
                        "models": [],
                        "categories": []
                    }
                ]
            },
            {
                "id": "regression",
                "name": "时空回归",
                "description": "时空回归分析是量化多元时空变量关系的统计分析算法，被广泛用于关系解释、归因分析和变量预测等。从时空变量关系的异质性或稳定性特征的角度，时空回归分析可细分为全局回归分析和局部回归分析。",
                "allModelsRecursive": [],
                "models": [],
                "categories": [
                {
                        "id": "global_regression",
                        "name": "全局空间回归",
                        "description": "全局空间回归分析技术是指在不考虑空间位置特征的前提下对多元空间变量关系的定量分析技术，以实现全局视角下的关系解释、归因推理和变量预测等功能。",
                        "allModelsRecursive": [],
                        "models": [
                            {
                                "id": "9c337f78-5b57-3294-98a4-e798fa543733",
                                "name": "Prophet预测",
                                "description": "时间序列预测"
                            }
                        ],
                        "categories": []
                    },
                ]
            },
        ];
    const targetDatam = {
    title:"",
    key:0,
    children:[]
    }

    // const targetData = rawData.map(item=>{
    //   return {
    //     title:item.name,
    //     key:item.id,
    //     children:item.categories
    //   }
    // })

    const format = (node) => {
        return {
            title: node?.name,
            key: node.id,
            children: (node?.categories ?? []).map(format).concat(
              // 若一级类下有模型，就连接
                node?.models?.map((models) => {
                    return {
                        title: models?.name,
                        key: models.id,
                        description:models.description,
                        isLeaf: true,
                        originData: models,
                    };
                }),
            ),
        };
    };

    const targetData = rawData.map((item) => format(item))
    console.log("rawData",rawData)
    console.log("targetData",targetData)
</script>
</html>
